1. Разработка выполнена в IntelliJ IDEA 2021.2.2 (Community Edition)
2. Версия JDK 17
3. Версия корутин 1.5.2

**Математическая модель**
  
В задании предложено выделить уникальные Ip-адреса из текcтового файла, используя только стандартную библиотеку Kotlin, минимизируя И использование памяти И время обработки. Для решения этой задачи предложено следующее: в ходе первичного анализа -- возможность представить все четыре байта Ip-адреса как координаты 4-мерного куба, и описать хранение 4-х мерным массивом байт; в каждой координатной точке этого куба размещается счетчик повторений Ip-адреса (точки координат). Далее, в ходе вторичного анализа, получается что для выполнения условия задания, а именно - выделение УНИКАЛЬНЫХ, то есть встретившихся только ОДИН РАЗ IP-адресов, достаточно двухбитового счетчика (целый байт НЕ нужен) -- два бита способны хранить до 4х состояний, а для выделения УНИКАЛЬНЫХ IP-адресов достаточно трёх состояний:

- IP-адрес -- не встречался, значение 0
- IP-адрес -- уникальный, значение 1
- IP-адрес -- неуникальный, значение 2 
  
Таким образом, вместо хранения 256*256*256*256 байт, что равно 4294967296 или ровно 4 Гигабайт, выполнен переход к хранению по 4 двухбитовых счетчика на каждый хранимый байт или уменьшение хранения до ровно 1 Гигабайт. Далее, при третьем анализе, выполнена "свертка" 4х-мерного пространства до одномерного с помощью фиксации логики расположения байта в массиве -- по моему опыту обработки покадрового видео в потоке, именно одномерные массивы являются самым производительным хранилищем. Такое фильтрующее хранилище использует теоретический минимум занимаемого места - всего ДВА БИТА на IP-адрес, а сам IP-адрес нигде в явном виде - не хранится, а представляет собой лишь ВЕЛИЧИНУ СМЕЩЕНИЯ в одномерном поле 4294967296 двухбитовых счетчиков, хранимых в 1073741824 байт.
  
**Плюсы предложенной модели**
  
1. МИНИМИЗАЦИЯ хранения ДЛЯ ВСЕХ возможных вариантов IP-адресов - всего ДВА БИТА на один IP-адрес
2. Второй, важный плюс для обеспечения МИНИМИЗАЦИИ ВРЕМЕНИ ОБРАБОТКИ -- ОДИНАКОВОЕ КОЛИЧЕСТВО ПРОЦЕССОРНЫХ ДЕЙСТВИЙ как для первого IP-адреса, так и миллионного и стомиллионного -- НЕТ НАКОПЛЕНИЯ СРАВНЕНИЯ ПО МЕРЕ НАКОПЛЕНИЯ УЖЕ ПОЛУЧЕННЫХ УНИКАЛЬНЫХ АДРЕСОВ, все действия - простые вычислительные а не на основе множественного сравнения
  
**Первая фаза работы выполненного решения**
  
Сама процедура фильтрации во время построчного чтения входного файла, сводится к расчету/выделению требуемого счетчика, соответствующему в фильтрующем массиве прочитанному конкретному IP-адресу, и увеличению его на единицу с тем условием, что если сумма стала более чем ОДИН, то всё остальное - всегда ДВА; так обрабатываются все строки(IP-адреса) входного файла.
  
Таким образом предложенное решение может обработать файл ЛЮБОЙ длины НЕ УВЕЛИЧИВАЯ фильтрующее хранение по мере поступления новых и новых IP-адресов -- фильтр имеет фиксированный размер с самого начала, и НЕ УВЕЛИЧИВАЕТ количество вычислений по мере поступления все новых и новых IP-адресов.
  
**Вторая фаза** - чтение всех счетчиков и, если в конкретном счетчике установилось значение "1", то сформировать
   IP-адрес из индекса массива хранения и номера счетчика в байте, и затем сохранить IP-адрес в выходной файл
  
При проработке реализации, было перепробовано несколько вариантов реализации многопоточности,
практика показала что введение любых блокировок для разделения совместного использования переменных, В ЗНАЧИТЕЛЬНОЙ СТЕПЕНИ замедляет время выполнения; произведен чистый эксперимент, простой инкремент ПРИ ЕДИНСТВЕННОМ ОБРАЩАЮЩЕМСЯ ПРОЦЕССЕ заменен на инкремент в условиях @Syncronized, второй вариант замены был выполнен через Lock -- даже эта элементарная замена значительно замедляла время работы.
Таким образом, выполненное и приложенное к этому письму решение является самым быстрым из перепробованных мной вариантов реализации; для максимальной скорости выполнения вычисления упрощены насколько это возможно.
  
   В дополнение, есть представление о том как уменьшить время работы выполненного решения ценой увеличения использования памяти,
   пояснения по этому поводу - тема отдельной коммуникации

   Для визуализации относительно длительных процессов и обработки файла при чтении, и обработки массива
   при записи, введено однострочное отображение количества выполненных процентов обработки, обновляемое пять раз в секунду.
  
**Результаты тестов**
1. Отрезок от файла ip_addresses размером приблизительно в 10 мегабайт(10 737 416 байт), содержит ПОЛНОСТЬЮ УНИКАЛЬНЫЕ IP-адреса в количестве 755648 адресов
   Прилагаю файл part_2_755648.txt, и результат работы программы part_2_outIp_755648.txt

2. Для тестирования фильтрующей способности выполненного решения, я скопировал один из IP-адресов в файле part_2_755648.txt, 97.71.173.235, из третьей строчки в четырнадцатую, получил файл, прилагаю его также, part_21_755648.txt. В результате обработки получен файл part_21_outIp_755646.txt который содержит уже на две выходных строки меньше. Так и должно быть, ведь один адрес стал НЕУНИКАЛЬНЫМ и отфильтрован, а второй я заместил при переписывании в четырнадцатую строку значения 97.71.173.235. Таким образом, если открыть файл part_21_outIp_755646.txt то можно видеть, что отфильтрованного вследствие повтора значения 97.71.173.235 там - нет.

3. Отрезок от файла ip_addresses размером приблизительно в 1 гигабайт (1 073 741 819 байт), содержит 75540194 IP-адресов и все они - уникальны

4. Главный результат - в файле ip_addresses содержится РОВНО  8 000 000 000  IP-адресов, и все они - НЕУНИКАЛЬНЫ; ни одного уникального IP-адреса в ходе выполненного теста обнаружено - не было
